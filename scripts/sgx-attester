#!/usr/bin/env python3.5

import argparse
import socket
import logging
import json

from sgx_attester.util import get_public_key, get_private_key, check_json
from sgx_attester.crypto import generate_ecdh_key_pair
from sgx_attester.crypto import derive_key
from sgx_attester.crypto import derive_shared_key
from sgx_attester.crypto import create_key_signature
from sgx_attester.crypto import create_msg2_mac
from sgx_attester.crypto import verify_msg3_mac
from sgx_attester.crypto import verify_msg3_report_data


QUOTE_UNLINKABLE_SIGNATURE = b"\x00\x00"
QUOTE_LINKABLE_SIGNATURE = b"\x01\x00"

KDF_ID = b"\x01\x00"


class Attester(object):
    def __enter__(self):
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.socket.__enter__()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.socket.__exit__(exc_type, exc_val, exc_tb)

    def __init__(self, dest_host, dest_port):
        self.dest_host = dest_host
        self.dest_port = dest_port
        self.epid_group_id = None
        self.enclave_public_key = None
        self.public_key = None
        self.quote = None
        self.msg3_mac = None
        self.platform_service_security_properties = None
        self.revocation_list = None
        self.shared_key = None
        self.session_mac_key = None
        self.long_term_private_key = get_private_key()
        self.long_term_public_key = get_public_key()
        self.verification_result = None

    def execute(self):
        self.socket.connect((self.dest_host, self.dest_port))
        self.send_attestation_request()

        self.receive_msg0()
        self.receive_msg1()

        self.send_msg2()

        self.receive_msg3()
        self.process_msg3()

        self.send_msg4()

    def send_attestation_request(self):
        self.socket.sendall(b"attest")

    def receive_msg0(self):
        received_raw = self.socket.recv(1024)
        logging.debug("Received: %s", received_raw)

        received_json = json.loads(received_raw.decode('utf8'))
        check_json(received_json, dict, 1)

        self.epid_group_id = received_json["epid"]

    def receive_msg1(self):
        received_raw = self.socket.recv(1024)
        logging.debug("Received: %s", received_raw)

        received_json = json.loads(received_raw.decode('utf8'))
        check_json(received_json, dict, 1)
        check_json(received_json["public_key"], str, 128)

        self.enclave_public_key = bytes.fromhex(received_json["public_key"])
        logging.info("enclave public key: %r", self.enclave_public_key.hex())

    def send_msg2(self):
        logging.debug("Preparing to send Msg2")
        revocation_list = self.get_revocation_list(self.epid_group_id)

        self.public_key, private_key = generate_ecdh_key_pair()
        logging.info("my public key: %r", self.public_key.hex())

        self.shared_key = derive_shared_key(private_key, self.public_key, self.enclave_public_key)
        logging.info("shared key: %r", self.shared_key.hex())

        key_signature = create_key_signature(self.long_term_private_key,
                                             self.long_term_public_key,
                                             self.public_key,
                                             self.enclave_public_key)
        logging.info("key signature: %r\n", key_signature.hex())

        self.session_mac_key = derive_key(self.shared_key, b'SMK')
        logging.info("session MAC key: %r\n", self.session_mac_key.hex())

        fake_spid = b"Service X" + b"\x00" * 7
        quote_type = QUOTE_UNLINKABLE_SIGNATURE

        mac = create_msg2_mac(self.session_mac_key, self.public_key, fake_spid, quote_type, KDF_ID, key_signature)
        logging.info("MAC: %r\n", mac.hex())

        msg2 = json.dumps({"public_key": self.public_key.hex(),
                           "spid": fake_spid.hex(),
                           "quote_type": quote_type.hex(),
                           "kdf_id": KDF_ID.hex(),
                           "key_signature": key_signature.hex(),
                           "mac": mac.hex(),
                           "revocation_list": revocation_list.hex()}).encode()

        self.socket.sendall(msg2)
        logging.info("Msg2 sent")

    @staticmethod
    def get_revocation_list(epid_group_id):
        # XXX: In production mode, this should connect to the Intel Attestation Service
        # to receive the signature revocation list for the specified EPID group ID
        logging.warning("Skipping receiving revocation list: Not implemented yet")
        return bytes()

    def receive_msg3(self):
        received_raw = self.socket.recv(4096)
        logging.debug("Received (size: %s): %s", len(received_raw), received_raw)

        received_json = json.loads(received_raw.decode('utf8'))
        check_json(received_json, dict, 3)

        self.quote = bytes.fromhex(received_json["quote"])
        self.msg3_mac = bytes.fromhex(received_json["mac"])
        self.platform_service_security_properties = bytes.fromhex(received_json["platform_service_security_properties"])

    def process_msg3(self):
        verify_msg3_mac(
            self.msg3_mac,
            self.session_mac_key,
            self.enclave_public_key,
            self.quote,
            self.platform_service_security_properties
        )

        report_data = self.quote[368:432]
        verify_msg3_report_data(report_data, self.enclave_public_key, self.public_key, self.shared_key)

        self.verification_result = self.verify_quote(self.quote)
        logging.info("Msg3 processed")

    @staticmethod
    def verify_quote(quote):
        # XXX: Request developer service access [1] and use IAS [2] to verify quote
        # [1] https://software.intel.com/formfill/sgx-onboarding
        # [2] https://software.intel.com/sites/default/files/managed/7e/3b/ias-api-spec.pdf
        logging.warning("Skipped verifying quote: Not implemented yet")
        return True

    def send_msg4(self):
        msg4 = json.dumps({"verification_result": self.verification_result}).encode()
        self.socket.sendall(msg4)
        logging.info("Msg4 sent")


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--verbose", "-v", action="store_true", help="Print debug messages")
    mode = parser.add_mutually_exclusive_group(required=True)
    mode.add_argument("--listen", "-l", action="store_true",
                      help="Listen for attestation attempts on address ADDRESS on port PORT")
    mode.add_argument("--connect", "-c", action="store_true", help="Request attestation from host ADDRESS on port PORT")
    parser.add_argument("ADDRESS", type=str)
    parser.add_argument("PORT", type=int)

    return parser.parse_args()


def init(args):
    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)

    logging.getLogger('sh').setLevel(logging.INFO)


def main():
    args = parse_args()
    init(args)

    if args.listen:
        raise NotImplementedError()

    with Attester(args.ADDRESS, args.PORT) as attester:
        attester.execute()


if __name__ == "__main__":
    main()
