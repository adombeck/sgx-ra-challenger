#!/usr/bin/env python3.5

import argparse
import socket
import logging
import json

from sgx_attester.util import get_public_key, get_private_key, get_mrenclave, check_json
from sgx_attester.crypto import generate_ecdh_key_pair
from sgx_attester.crypto import derive_key
from sgx_attester.crypto import derive_shared_key
from sgx_attester.crypto import create_key_signature
from sgx_attester.crypto import create_msg2_mac
from sgx_attester.crypto import verify_msg3_mac
from sgx_attester.crypto import verify_msg3_report_data
from sgx_attester.crypto import verify_quote_mrenclave
from sgx_attester.config import QUOTE_TYPE, SPID
from sgx_attester import ias


class InvalidExtendedEpidGidError(Exception):
    pass

KDF_ID = b"\x01\x00"


class Attester(object):
    def __enter__(self):
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.socket.__enter__()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.socket.__exit__(exc_type, exc_val, exc_tb)

    def __init__(self, dest_host, dest_port):
        self.dest_host = dest_host
        self.dest_port = dest_port
        self.extended_epid_gid = None
        self.epid_gid = None
        self.enclave_public_key = None
        self.public_key = None
        self.quote = None
        self.msg3_mac = None
        self.platform_service_security_properties = None
        self.revocation_list = None
        self.shared_key = None
        self.session_mac_key = None
        self.long_term_private_key = get_private_key()
        self.long_term_public_key = get_public_key()
        self.mrenclave = get_mrenclave()
        self.quote_type = QUOTE_TYPE
        self.spid = bytes.fromhex(SPID)
        self.verification_result = None

    def execute(self):
        self.socket.connect((self.dest_host, self.dest_port))
        self.send_attestation_request()

        self.receive_msg0()
        self.process_msg0()

        self.receive_msg1()

        self.send_msg2()

        self.receive_msg3()
        self.process_msg3()

        self.send_msg4()

    def send_attestation_request(self):
        self.socket.sendall(b"attest")

    def receive_msg0(self):
        received_raw = self.socket.recv(1024)
        logging.debug("Received: %s", received_raw)

        received_json = json.loads(received_raw.decode('utf8'))
        check_json(received_json, dict, 1)

        self.extended_epid_gid = received_json["extended_epid_gid"]

    def process_msg0(self):
        if self.extended_epid_gid != 0:
            # Extended EPID group ID != 0 means that the enclave was provisioned to use another attestation service
            # than Intel's. This is currently unsupported.
            # See: https://software.intel.com/en-us/forums/intel-software-guard-extensions-intel-sgx/topic/671363
            raise InvalidExtendedEpidGidError("Received invalid extended EPID group ID %r" % self.extended_epid_gid)

    def receive_msg1(self):
        received_raw = self.socket.recv(1024)
        logging.debug("Received: %s", received_raw)

        received_json = json.loads(received_raw.decode('utf8'))
        check_json(received_json, dict, 2)
        check_json(received_json["public_key"], str, 128)
        check_json(received_json["epid_gid"], str, 8)

        self.enclave_public_key = bytes.fromhex(received_json["public_key"])
        self.epid_gid = bytes.fromhex(received_json["epid_gid"])
        logging.info("enclave public key: %r", self.enclave_public_key.hex())
        logging.info("EPID group ID: %r", self.epid_gid.hex())

    def send_msg2(self):
        logging.debug("Preparing to send Msg2")
        revocation_list = self.get_revocation_list(self.epid_gid)

        self.public_key, private_key = generate_ecdh_key_pair()
        logging.info("my public key: %r", self.public_key.hex())

        self.shared_key = derive_shared_key(private_key, self.enclave_public_key)
        logging.info("shared key: %r", self.shared_key.hex())

        key_signature = create_key_signature(self.long_term_private_key,
                                             self.public_key,
                                             self.enclave_public_key)
        logging.info("key signature: %r\n", key_signature.hex())

        self.session_mac_key = derive_key(self.shared_key, b'SMK')
        logging.info("session MAC key: %r\n", self.session_mac_key.hex())

        mac = create_msg2_mac(self.session_mac_key, self.public_key, self.spid, self.quote_type, KDF_ID, key_signature)
        logging.info("MAC: %r\n", mac.hex())

        msg2 = json.dumps({"public_key": self.public_key.hex(),
                           "spid": self.spid.hex(),
                           "quote_type": self.quote_type.hex(),
                           "kdf_id": KDF_ID.hex(),
                           "key_signature": key_signature.hex(),
                           "mac": mac.hex(),
                           "revocation_list": revocation_list.hex()}).encode()

        self.socket.sendall(msg2)
        logging.info("Msg2 sent")

    @staticmethod
    def get_revocation_list(epid_gid: bytes):
        return ias.retrieve_sigrl(epid_gid)

    def receive_msg3(self):
        received_raw = self.socket.recv(4096)
        logging.debug("Received (size: %s): %s", len(received_raw), received_raw)

        received_json = json.loads(received_raw.decode('utf8'))
        check_json(received_json, dict, 3)

        self.quote = bytes.fromhex(received_json["quote"])
        self.msg3_mac = bytes.fromhex(received_json["mac"])
        self.platform_service_security_properties = bytes.fromhex(received_json["platform_service_security_properties"])

        logging.debug("quote: %r", self.quote)

    def process_msg3(self):
        verify_msg3_mac(
            self.msg3_mac,
            self.session_mac_key,
            self.enclave_public_key,
            self.quote,
            self.platform_service_security_properties
        )

        report_data = self.quote[368:432]
        verify_msg3_report_data(report_data, self.enclave_public_key, self.public_key, self.shared_key)

        self.verify_quote(self.quote)
        self.verification_result = True
        logging.info("Msg3 processed")

    def verify_quote(self, quote):
        # XXX: Request developer service access [1] and use IAS [2] to verify quote
        # [1] https://software.intel.com/formfill/sgx-onboarding
        # [2] https://software.intel.com/sites/default/files/managed/7e/3b/ias-api-spec.pdf
        verify_quote_mrenclave(quote, self.mrenclave)
        ias.verify_quote(quote)

    def send_msg4(self):
        msg4 = json.dumps({"verification_result": self.verification_result}).encode()
        self.socket.sendall(msg4)
        logging.info("Msg4 sent")


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--verbose", "-v", action="store_true", help="Print debug messages")
    mode = parser.add_mutually_exclusive_group(required=True)
    mode.add_argument("--listen", "-l", action="store_true",
                      help="Listen for attestation attempts on address ADDRESS on port PORT")
    mode.add_argument("--connect", "-c", action="store_true", help="Request attestation from host ADDRESS on port PORT")
    parser.add_argument("ADDRESS", type=str)
    parser.add_argument("PORT", type=int)

    return parser.parse_args()


def init(args):
    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)

    logging.getLogger('sh').setLevel(logging.INFO)


def main():
    args = parse_args()
    init(args)

    if args.listen:
        raise NotImplementedError()

    with Attester(args.ADDRESS, args.PORT) as attester:
        attester.execute()


if __name__ == "__main__":
    main()
