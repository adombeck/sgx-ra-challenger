#!/usr/bin/env python3.5

import argparse
import socket
import logging
import json
import pyelliptic
import Crypto.Hash.CMAC
import Crypto.Cipher.AES


from sgx_attester import util
from sgx_attester.config import CURVE

QUOTE_UNLINKABLE_SIGNATURE = b"\x00\x00"
QUOTE_LINKABLE_SIGNATURE = b"\x01\x00"

KDF_ID = b"\x01\x00"


class ECCPublicKey(object):
    def __init__(self, gx: bytes, gy: bytes):
        self.gx = gx
        self.gy = gy

    def get_pubkey(self):
        """Returns the public key in the format expected by pyelliptic (which uses OpenSSL internally)"""
        # I don't know why the '04' is required, but this is what pyelliptic expects
        return b'04' + self.gx + self.gy


class Attester(object):
    def __enter__(self):
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.socket.__enter__()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.socket.__exit__(exc_type, exc_val, exc_tb)

    def __init__(self, dest_host, dest_port):
        self.dest_host = dest_host
        self.dest_port = dest_port
        self.epid_group_id = None
        self.enclave_public_key = None
        self.revocation_list = None
        self.shared_key = None
        self.long_term_private_key = util.get_private_key()

    def execute(self):
        self.socket.connect((self.dest_host, self.dest_port))
        self.send_attestation_request()

        self.receive_msg0()
        self.receive_msg1()

        self.send_msg2()
        # XXX: incomplete

    def send_attestation_request(self):
        self.socket.sendall(b"attest")

    def receive_msg0(self):
        received_raw = self.socket.recv(1024)
        logging.debug("Received: %s", received_raw)

        received_json = json.loads(received_raw.decode('utf8'))
        assert isinstance(received_json, dict)
        assert len(received_json) == 1

        self.epid_group_id = received_json["EPID"]

    def receive_msg1(self):
        received_raw = self.socket.recv(1024)
        logging.debug("Received: %s", received_raw)

        received_json = json.loads(received_raw.decode('utf8'))
        assert isinstance(received_json, dict)
        assert len(received_json) == 1
        assert isinstance(received_json["public_key"], str)
        assert len(received_json["public_key"]) == 128

        self.enclave_public_key = bytes.fromhex(received_json["public_key"])
        logging.info("enclave public key: %r", self.enclave_public_key.hex())

    def send_msg2(self):
        revocation_list = self.get_revocation_list(self.epid_group_id)

        public_key, private_key = self.generate_ecdh_key_pair()
        logging.info("my public key: %r", public_key.hex())

        self.shared_key = self.derive_shared_key(private_key, self.enclave_public_key)
        logging.info("shared key: %r", self.shared_key.hex())

        key_signature = self.create_key_signature(self.long_term_private_key, public_key, self.enclave_public_key)
        logging.info("key signature: %r", key_signature.hex())

        session_mac_key = self.derive_key(self.shared_key, b'SMK')
        logging.info("session MAC key: %r", session_mac_key.hex())

        fake_spid = b"\x00" * 16
        quote_type = QUOTE_UNLINKABLE_SIGNATURE
        authenticated_bytes = public_key + fake_spid + QUOTE_UNLINKABLE_SIGNATURE + KDF_ID + key_signature
        mac = self.create_mac(session_mac_key, authenticated_bytes)

        msg2 = json.dumps({"public_key": public_key.hex(),
                           "spid": fake_spid.hex(),
                           "quote_type": QUOTE_UNLINKABLE_SIGNATURE.hex(),
                           "kdf_id": KDF_ID.hex(),
                           "key_signature": key_signature.hex(),
                           "mac": mac.hex(),
                           "revocation_list": revocation_list}).encode()

        self.socket.sendall(msg2)

    @staticmethod
    def get_revocation_list(epid_group_id):
        # XXX: In production mode, this should connect to the Intel Attestation Service
        # to receive the signature revocation list for the specified EPID group ID
        return list()

    @staticmethod
    def generate_ecdh_key_pair():
        # P-256 was deprecated by the NSA in 2015 for unknown reasons.
        # See: https://blog.cryptographyengineering.com/2015/10/22/a-riddle-wrapped-in-curve/
        # We should probably use something else, but the Intel SDK functions only support P-256.
        ecc = pyelliptic.ECC(curve=CURVE)
        return ecc.get_pubkey(), ecc.get_privkey()

    @staticmethod
    def derive_shared_key(private_key, public_key):
        ecc = pyelliptic.ECC(privkey=private_key, curve=CURVE)
        return ecc.get_ecdh_key(b'\x04' + public_key)

    @staticmethod
    def derive_key(shared_key, label):
        empty_key = b'\x00' * 16
        cobj1 = Crypto.Hash.CMAC.new(empty_key, ciphermod=Crypto.Cipher.AES)
        cobj1.update(shared_key)
        tmp_key = cobj1.digest()

        derivation_string = b'\x01' + label + b'\x00' + b'\x80\x00'
        cobj2 = Crypto.Hash.CMAC.new(tmp_key, ciphermod=Crypto.Cipher.AES)
        cobj2.update(derivation_string)
        session_mac_key = cobj2.digest()

        return session_mac_key

    @staticmethod
    def create_key_signature(private_key, attester_public_key, enclave_public_key):
        return pyelliptic.ECC(privkey=private_key, curve=CURVE).sign(attester_public_key + enclave_public_key)

    @staticmethod
    def create_mac(mac_key, text):
        cobj = Crypto.Hash.CMAC.new(mac_key, ciphermod=Crypto.Cipher.AES)
        cobj.update(text)
        return cobj.digest()


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--verbose", "-v", action="store_true", help="Print debug messages")
    mode = parser.add_mutually_exclusive_group(required=True)
    mode.add_argument("--listen", "-l", action="store_true",
                      help="Listen for attestation attempts on address ADDRESS on port PORT")
    mode.add_argument("--connect", "-c", action="store_true", help="Request attestation from host ADDRESS on port PORT")
    parser.add_argument("ADDRESS", type=str)
    parser.add_argument("PORT", type=int)

    return parser.parse_args()


def init(args):
    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)


def main():
    args = parse_args()
    init(args)

    if args.listen:
        raise NotImplementedError()

    with Attester(args.ADDRESS, args.PORT) as attester:
        attester.execute()



if __name__ == "__main__":
    main()
